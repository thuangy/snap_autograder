<!DOCTYPE html>
<html>
<head>
    <title>Snap! Build Your Own Blocks. Beta</title>
    <link rel="shortcut icon" href="http://snap.berkeley.edu/fav3.gif" type="image/gif">
    <script src="jschannel.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
    <script src="http://underscorejs.org/underscore-min.js"></script>
    <script type="text/javascript" src="SnapPLE.js"></script>
    <!-- Moved down to the bottom to have var id. -->
    
    <script type="text/javascript" src="snap.js"></script>

    <link rel="stylesheet" type="text/css" href="AG_status_bar.css" />
    <link rel="stylesheet" type="text/css" href="hintstyle.css" />
    <script type="text/javascript" src="AG_hint_format.js"></script>

    <script type="text/javascript">
        // The id is to act as a course identifier.
        // NOTE: FOR NOW YOU ALSO HAVE TO ADD THE ID TO THE BOTTOM OF THE PAGE.
        var courseID = "";  // e.g. "BJCx"
        // Specify a prerequisite task id, should be null if no such requirement.
        var preReqTaskID = null;
        var preReqID = courseID + preReqTaskID;
        // taskID uniquely identifies the task for saving in browser localStorage.
        var taskID = "AG_D1_T1";
        var id = courseID + taskID;
        var assert;
        var pos_fb = "The 'factorial' block is present.";
        var neg_fb = "The 'factorial %num' block was not found on-screen.";

        // Add tests to the outputLog. Function is called by runAGTest(id, outputLog)
        // var testLog;
        function AGTest(outputLog) {
            /* Factorial */

            var assert1 = function assert1() {
                return isScriptPresent('factorial %s',0);
            }


            assert = function assert() {
                testAssert(outputLog, assert1,//isScriptPresent('factorial %s',0),
                pos_fb, neg_fb, "Make sure you name your custom block, 'factorial %num'.");
            }
            assert();
            /*testAssert(outputLog, assert1,//isScriptPresent('factorial %s',0),
                "The 'factorial' block is present.",
                "The 'factorial %num' block was not found on-screen.",
                "Make sure you name your custom block, 'factorial %num'.");*/
            // testAssert(outputLog, CBlockContainsInCustom('factorial %s', 0,
            //     'if %c else %c', 'report %s'),
            //     "The factorial block;
            multiTestBlock('factorial %s', 
                [[0],[1],[2],[4],[5],[10]],
                [1,1,2,24,120,3628800],
                [-1,-1,-1,-1,-1,-1],
                outputLog);

            /*var assert1 = function assert1() {
                isScriptPresent('factorial %s',0);
            }*/
            // /* KScopeTest */
            // testAssert(outputLog, 
            //     spriteContainsBlock('when %keyHat key pressed', 0, ['space']) &&
            //     spriteContainsBlock('when %keyHat key pressed', 1, ['space']) &&
            //     spriteContainsBlock('when %keyHat key pressed', 2, ['space']) &&
            //     spriteContainsBlock('when %keyHat key pressed', 3, ['space']),
            //     "All sprites have the 'when [space] key pressed' hat-block.",
            //     "All sprites must have a 'when [space] key pressed' hat-block.",
            //     "The Kaleidoscope should begin drawing when the 'space' key is pressed.");
            // testAssert(outputLog,
            //     spriteContainsBlock('forever %c', 0) &&
            //     spriteContainsBlock('forever %c', 1) &&
            //     spriteContainsBlock('forever %c', 2) &&
            //     spriteContainsBlock('forever %c', 3),
            //     "All sprites have a forever loop",
            //     "All sprites must have a 'forever' loop.",
            //     "The 'forever' loop is required.");
            // testAssert(outputLog,
            //     spriteContainsBlock('go to x: %n y: %n', 0) &&
            //     spriteContainsBlock('go to x: %n y: %n', 1) &&
            //     spriteContainsBlock('go to x: %n y: %n', 2) &&
            //     spriteContainsBlock('go to x: %n y: %n', 3),
            //     "All sprites have a 'go to' motion-block",
            //     "All sprites must have a 'go to' motion-block",
            //     "The 'go to' motion-block is required.");
            // testAssert(outputLog,
            //     spriteContainsBlock('pen down', 0) &&
            //     spriteContainsBlock('pen down', 1) &&
            //     spriteContainsBlock('pen down', 2) &&
            //     spriteContainsBlock('pen down', 3),
            //     "All sprites have a 'pen down' pen-block",
            //     "All sprites must have a 'pen down' pen-block",
            //     "The 'pen down' pen-block is required.");
            // testKScope(outputLog);
            
            return outputLog;
        }

        /* Removes the previously saved AG_state. Runs the tests in
         * AGTest().
         * Called by 'click' event on autograder_button.
         */
        function runAGTest(snapWorld, taskID, outputLog) {
            // Create a new gradingLog if none is specified.
            outputLog = outputLog || new gradingLog(snapWorld, taskID);
            // Populate, run, and evaluate the tests specified in AGTest()
            // These tests specified by the Course Designer. 

            //outputLog.numAttempts += 1;

            var test_log = AGTest(outputLog);
            if(!test_log.runSnapTests()) {
                outputLog.scoreLog();
            }
        }

        /* After loading the XML, check if the current XML is a known
         * state, restore the gradingLog if it is.
         * @return {gradingLog}
         * TODO: Trigger AGStart when a Snap file is loaded.
         */
        function AGStart(snapWorld, taskID) {
            //Grab HTML divs
            var menu_button = document.getElementById("onclick-menu");
            var grade_button = document.getElementById("autograding_button");
            //Get the current Snap XML string
            var ide = snapWorld.children[0];
            var curr_xml = ide.serializer.serialize(ide.stage);
            //Retrieve previously graded Snap XML strings (if in localStorage).
            var c_prev_xml = localStorage.getItem(taskID + "_c_test_state");
            var prev_xml = localStorage.getItem(taskID + "_test_state");

            var outputLog;
            //If the current XML matches the stored correct XML
            if (isSameSnapXML(c_prev_xml, curr_xml)) {
                //Restore the AG status bar to a graded state
                var outputLog = JSON.parse(localStorage.getItem(taskID + "_c_test_log"));
                outputLog.snapWorld = snapWorld;
                AG_bar_graded(outputLog);
                return outputLog;
            }
            //If the current XML matches the last stored gradingLog
            if (isSameSnapXML(prev_xml, curr_xml)) {
                //Restore the AG status bar to a graded state
                var outputLog = JSON.parse(localStorage.getItem(taskID + "_test_log"));
                outputLog.snapWorld = snapWorld;
                AG_bar_semigraded(outputLog);
                return outputLog; 
            } else {
                //Restore the AG status bar to a graded state
                //If no previous state is recognized, return new {gradingLog}.
                outputLog = new gradingLog(snapWorld, taskID); 
                AG_bar_ungraded(outputLog);
                return outputLog;
            }   
        }
        /* Checks to see if the Snap! XML has changed and updates the
         * AG status bar. If Snap! is restored to its former state
         * the grading log and status bar are also restored.
         * @return {gradingLog} outputLog
         * Note:
         *  - Should only be called from a "mouseup" event.
         */
        function AGUpdate(snapWorld, taskID) {
            console.log("AGUpdate");

            

            //TODO: Are there any optional parameters that may be useful?
            //Grabs HTML divs
            var menu_button = document.getElementById("onclick-menu");
            var grade_button = document.getElementById("autograding_button");
            //Get the current Snap XML string
            var ide = snapWorld.children[0];
            var curr_xml = ide.serializer.serialize(ide.stage);
            //Retrieve previously graded Snap XML strings (if in localStorage).
            var c_prev_xml = localStorage.getItem(taskID + "_c_test_state");
            var prev_xml = localStorage.getItem(taskID + "_test_state");

            var last_xml = localStorage.getItem(taskID + "_last_submitted_state");
            //Retrieve previous grade logs (if in localStorage). As {String}s
            var c_prev_log = localStorage.getItem(taskID + "_c_test_log");
            var prev_log = localStorage.getItem(taskID + "_test_log");
            if (!prev_xml || !curr_xml) {
                console.log(prev_xml);
                console.log(curr_xml);
            }


            //menu bar grays out options that are not available (ex. current state is same as best attempt) and restores the button state

            /*var last_submit = document.getElementById("last-submit");
            if (last_xml === null || isSameSnapXML(last_xml, curr_xml)) {
                last_submit.style.color = "#373737";
                last_submit.style.pointerEvents = "none";
                last_submit.parentNode.id = "disabled-button";
            } else {
                last_submit.parentNode.id = "enabled-button";
                last_submit.style.color = "white";
                last_submit.style.pointerEvents = "auto";
            }

            var revert_button = document.getElementById("revert-button");
            if (c_prev_xml === null || isSameSnapXML(c_prev_xml, curr_xml)) {
                revert_button.style.color = "#373737";
                revert_button.style.pointerEvents = "none";
                revert_button.parentNode.id = "disabled-button";
            } else {
                revert_button.parentNode.id = "enabled-button";
                revert_button.style.color = "white";
                revert_button.style.pointerEvents = "auto";
            }

            var undo_button = document.getElementById("undo-button");
            if (prev_xml === null || isSameSnapXML(prev_xml, curr_xml)) {
                undo_button.style.color = "#373737";
                undo_button.style.pointerEvents = "none";
                undo_button.parentNode.id = "disabled-button";
            } else {
                undo_button.parentNode.id = "enabled-button";
                undo_button.style.color = "white";
                undo_button.style.pointerEvents = "auto";
            }*/

            grayOutButtons(world, id);

            var outputLog;
            //If current XML is different from prev_xml
            if (c_prev_xml && isSameSnapXML(c_prev_xml, curr_xml)) {               
                //Restore the AG status bar to a graded state
                
                // TODO: Write a good comment
                // TODO: Give gradeLog ability to recover log data and xml string
                console.log('AGUpdate: Thinks this is the "correct" XML.');
                localStorage.setItem(taskID + "_test_log", c_prev_log);
                localStorage.setItem(taskID + "_test_state", curr_xml);
                document.getElementById("different-feedback").innerHTML = "";

                //Retrieve the correct test log from localStorage
                outputLog = JSON.parse(c_prev_log);
                outputLog.snapWorld = snapWorld;
                AG_bar_graded(outputLog);
 
            } else if (prev_xml && isSameSnapXML(prev_xml, curr_xml, true)) {
                //Restore the AG status bar to a graded state
                console.log('AGUpdate: Thinks this is just the "last" XML.');
                //Retrieve the previous test log from localStorage
                document.getElementById("different-feedback").innerHTML = "";

                outputLog = JSON.parse(prev_log);
                outputLog.snapWorld = snapWorld;
                AG_bar_semigraded(outputLog);

            } else {
                //Restore the AG status bar to a graded state
                outputLog = new gradingLog(snapWorld, taskID);
                AG_bar_ungraded(outputLog);
                document.getElementById("different-feedback").innerHTML = "This feedback does not match what is in the scripting area."

            }
            //populateFeedback(outputLog);
            return outputLog;

        }

        /* Updates the AG_status_bar with respect to the outputLog. 
         *  - Formats CSS for 'autograding_flag' and 'autograding_button'
         * If the outputLog is correct, save the Snap XML string into 
         * localStorage.
         *  - key = outputLog.taskID + "_c_test_state"
         * Note:
         *  - Should only be called from outputLog.evaluateLog()
         */
        function AGFinish(outputLog) {

            //Grab HTML divs
            var menu_button = document.getElementById("onclick-menu");
            var grade_button = document.getElementById("autograding_button");
            // Verify correctness
            if (outputLog.allCorrect) {
                // Update AG_status_bar to Passing state
                // Save the correct XML string into localStorage
                AG_bar_graded(outputLog);
                outputLog.saveSnapXML(outputLog.taskID + "_c_test_state");

            } else {
                // Update AG_status_bar to 'graded, but incorrect state
                AG_bar_semigraded(outputLog);
            }
            outputLog.saveSnapXML(outputLog.taskID + "_test_state");
            //outputLog.numAttempts += 1;
            populateFeedback(outputLog);
            grayOutButtons(world, id);
            console.log('Autograder test Results:');
            console.log(outputLog);
        }



        function AG_bar_ungraded(outputLog) {
            
            var button_text = "GRADE";
            var button_elem = $('#autograding_button span');
            var regex = new RegExp(button_text,"g");
            if (button_elem.html().match(regex) !== null) {
                return;
            }
            button_elem.fadeOut('fast', function() {
                button_elem.html(button_text);
                button_elem.slideDown('fast');
                $('#autograding_button').css('background', 'orange');
            });          
            $('#autograding_button .hover_darken').show();
            $('#onclick-menu').css('color', 'white');
            $('#feedback-button').html("View Previous Feedback");
        }

        function AG_bar_graded(outputLog) {
            var button_text = "TESTS PASS";
            var button_elem = $('#autograding_button span');
            var regex = new RegExp(button_text,"g");
            if (button_elem.html().match(regex) !== null) {
                return;
            }
            
            button_elem.fadeOut('fast', function() {
                button_elem.html(button_text);
                button_elem.slideDown('fast');
                $('#autograding_button').css('background', '#29A629');
            });
            $('#autograding_button .hover_darken').hide();
            $('#onclick-menu').css('color', 'white');
            $('#feedback-button').html("Review Feedback");

        }

        function AG_bar_semigraded(outputLog) {
            var button_text = "&#x2770&#x2770 FEEDBACK";
            var button_elem = $('#autograding_button span');
            var regex = new RegExp("FEEDBACK","g");
            if (button_elem.html().match(regex) !== null) {
                return;
            }
            button_elem.fadeOut('fast', function() {
                button_elem.html(button_text);
                button_elem.slideDown('fast');
                $('#autograding_button').css('background', 'red');
            });
            $('#autograding_button .hover_darken').show();
            $('#onclick-menu').css('color', 'orange');
            var num_errors = outputLog.testCount - outputLog.numCorrect;
            var plural = "";
            if (num_errors > 1) { plural = "s"};
            $('#feedback-button').html("View Feedback ("+ 
                num_errors +" Error" + plural + ")");
        }

        /* Checks if two Snap! XML strings have approximately the same state.
         * The positions of scripts are ignored, as well as the order in which
         * they were most recently manipulated. 
         * @param {String} prev_xml
         * @param {String} curr_xml
         * @return {Boolean} Equivalence of prev_xml and curr_xml, false if
         * either are strings are undefined.
         * Currently only works for one sprite with scripts
         * TODO: Extend to all script groups [DONE]
         * TODO: Improve XML scrubbing (Consider the following)
         *  - If correct solution (scripts) is subset of other [DONE]
         *  - Optional tags for variables, sprite position  
         *  - Option to restore the highest scoring {gradingLog}
         *  
         * Note: Apparently works with multiple sprites, but produces a malformed
         * Snap XML string. Each sprite gets all scripts in sorted order. Needs
         * further testing.
        */
        function isSameSnapXML(prev_xml, curr_xml, no_subset) {
            //replace script coordinates with generic 'x="0" y="0"'
            // console.log('isSameSnapXML');
            if ((prev_xml === null) || (curr_xml === null)) {
                console.log("isSameSnapXML: prev_xml or curr_xml are null");
                console.log(prev_xml);
                console.log(curr_xml);
                return false;
            }
            
            //Remove script coordinates
            // prev_xml = prev_xml.replace(/script x="[\d]*" y="[\d]*"/g, 'script x="0" y="0"');
            // curr_xml = curr_xml.replace(/script x="[\d]*" y="[\d]*"/g, 'script x="0" y="0"');
            prev_xml = prev_xml.replace(/script x="(.*?)" y="(.*?)"/g, 'script x="0" y="0"');
            curr_xml = curr_xml.replace(/script x="(.*?)" y="(.*?)"/g, 'script x="0" y="0"');

            //Remove data hashes hashes (to allow coherence b/w reloads).
            prev_xml = prev_xml.replace(/data:image(.*?)(?=<)/g, '');
            curr_xml = curr_xml.replace(/data:image(.*?)(?=<)/g, '');

            // console.log('previous XML');
            // console.log(prev_xml);
            // console.log('current XML');
            // console.log(curr_xml);
            // console.log("They are the same:" + String(prev_xml === curr_xml));
            if (prev_xml === curr_xml) {
                return true;
            }

            //split between brackets
            prev_xml_scripts = prev_xml.match(/(<script x)(.*?)(<\/script>)/g);
            curr_xml_scripts = curr_xml.match(/(<script x)(.*?)(<\/script>)/g);

            //split between custom blocks
            prev_xml_blocks = prev_xml.match(/(<block-definition s)(.*?)(\/block-definition>)/g);
            curr_xml_blocks = curr_xml.match(/(<block-definition s)(.*?)(\/block-definition>)/g);
            
            //sort script tags and convert back to strings
            //lol. weird syntax. doesn't sort if curr_xml_scripts === null.
            prev_xml_scripts && prev_xml_scripts.sort().join("");
            curr_xml_scripts && curr_xml_scripts.sort().join("");

            //If the custom block definitions have changed
            prev_xml_blocks && prev_xml_blocks.sort().join("");
            curr_xml_blocks && curr_xml_blocks.sort().join("");
            if(JSON.stringify(prev_xml_blocks) !== JSON.stringify(curr_xml_blocks)) {
                console.log("THE CUSTOM BLOCKS ARE DIFFERENT!");
                console.log(prev_xml_blocks === curr_xml_blocks);
                console.log(JSON.stringify(prev_xml_blocks));
                console.log(JSON.stringify(curr_xml_blocks));
                return false;
            }

            //If the previous scripts are a subset of current scripts
            if (!no_subset && isArrSubset(curr_xml_scripts, prev_xml_scripts)) {
                //Then the solution is still present and in-tact
                return true;
            }

            //replace unsorted scripts with sorted scripts
            //TODO: Replace them properly
            prev_xml = prev_xml.replace(/(<script x)(.*)(<\/script>)/g,prev_xml_scripts);
            curr_xml = curr_xml.replace(/(<script x)(.*)(<\/script>)/g,curr_xml_scripts);
            console.log('previous XML');
            console.log(prev_xml);
            console.log('current XML');
            console.log(curr_xml);
            console.log("They are the same:" + String(prev_xml === curr_xml));

            return prev_xml === curr_xml;
        }

        function isArrSubset(big, small) {
            if (!big || !small) {
                return false;
            }
            nbig = big.slice();
            var index;
            for (var elem of small) {
                index = nbig.indexOf(elem);
                if (nbig.indexOf(elem) >= 0) {
                    nbig.slice(index, 1);
                } else {
                    return false;
                }
            }
            return true;
        }

        function escapeRegExp(string) {
            return string.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
        }

        function replaceall(string, find, replace) {
            return (string.replace(new RegExp(escapeRegExp(find), 'g'), replace));
        }

        /*
         * Re-format the contents of a the hint string to add HTML tags and
         * appropriate CSS. Return the re-formatted string.
         */
        function formatFeedback(hint) {
            var tags = 
            [['collapsedivstart', '<input class="toggle-box" id="expander" type="checkbox" ><label for="expander">Details</label><div id="table-wrapper">'], 
            ['collapsedivend', '</div>'], 
            ['linebreak', '<br /></br />'], 
            ['tablestart', '<table class="results">'], 
            ['tableend', '</table>'], 
            ['rowstart', '<tr>'], 
            ['rowend', '</tr>'], 
            ['headstart', '<th class="titles" style="text-align: center;">'], 
            ['headend', '</th>'], 
            ['datastart', '<td class="data" style="text-align: center;">'], 
            ['evenstart', '<td class="evens" style="text-align: center;">'],
            ['dataend', '</td>'], 
            ['correctstart', '<td class="correctans" style="text-align: center;">'],
            ['wrongstart', '<td class="incorrectans" style="text-align: center;">'],
            ['teststart', '<td class="tests" style="text-align: center;">'],
            ['spanend', '</span>'], 
            ['spanstart', '<span class="message">']];

            var taglength = tags.length;
            var message = String(hint.innerHTML);

            for (var i = 0; i < taglength; i++) {
                message = replaceall(message, tags[i][0], tags[i][1]);
            }
            return message;
        }

        function resetState(snapWorld, taskID) {

            localStorage.removeItem(taskID + "_test_log");
            localStorage.removeItem(taskID + "_test_state");
            localStorage.removeItem(taskID + "_c_test_log");
            localStorage.removeItem(taskID + "_c_test_state");

            var ide = snapWorld.children[0];
            ide.newProject();
            var new_log = AGStart(snapWorld, taskID);
            populateFeedback(new_log);
            grayOutButtons(world, id);
        }

        function revertToBestState(snapWorld, taskID) {
    
            var ide = snapWorld.children[0];

            var c_prev_xml = localStorage.getItem(taskID + "_c_test_state");
            var c_prev_log = localStorage.getItem(taskID + "_c_test_log");
            localStorage.setItem(taskID + "_test_state", c_prev_xml);
            localStorage.setItem(taskID + "_test_log", c_prev_log);

            var prev_log = JSON.parse(c_prev_log);
            prev_log.snapWorld = snapWorld;
            AG_bar_graded(prev_log);
            populateFeedback(prev_log);
            ide.openProjectString(c_prev_xml);
            grayOutButtons(world, id);
        }

        function revertToLastState(snapWorld, taskID) {

            var ide = snapWorld.children[0];
            var prev_xml = localStorage.getItem(taskID + "_test_state");
            var prev_log = JSON.parse(localStorage.getItem(taskID + "_test_log"));
            prev_log.snapWorld = snapWorld;
            if (prev_log['allCorrect']) {
                AG_bar_graded(prev_log);
            } else {
                AG_bar_semigraded(prev_log);
            }
            populateFeedback(prev_log);
            ide.openProjectString(prev_xml);
            grayOutButtons(world, id);
        }

        function revertToLastSubmit(snapWorld, taskID) {
            var last_xml = localStorage.getItem(taskID + "_last_submitted_state");
            var last_log = localStorage.getItem(taskID + "_last_submitted_log");
            var ide = snapWorld.children[0];

            localStorage.setItem(taskID + "_test_state", last_xml);
            localStorage.setItem(taskID + "_test_log", last_log);
            var prev_log = JSON.parse(last_log);
            if (prev_log['allCorrect']) {
                AG_bar_graded(prev_log);
            } else {
                AG_bar_semigraded(prev_log);
            }
            populateFeedback(prev_log);
            ide.openProjectString(last_xml);
            grayOutButtons(world, id);

        }

        function toggleMenu() {
            var menu_items = document.getElementsByClassName("bubble")[0];
            if (menu_items.id === "dropdown-closed") {
                menu_items.id = "dropdown-open";
            } else {
                menu_items.id = "dropdown-closed";
            }
        }

        function openPopup(){
            var overlay = document.getElementById('overlay');
            overlay.classList.remove("is-hidden");
        }

        function closePopup(){
            var overlay = document.getElementById('overlay');
            overlay.classList.add("is-hidden");
        }

        function openResults(){
            var overlay = document.getElementById('ag-output');
            overlay.classList.remove("is-hidden");
        }

        function closeResults(){
            var overlay = document.getElementById('ag-output');
            overlay.classList.add("is-hidden");
        }

        function populateFeedback(outputLog) {
            var taskID = outputLog.taskID;
            var last_log = localStorage.getItem(taskID + "_last_submitted_log");
            var prev_log = localStorage.getItem(taskID + "_test_log");
            var edx_caution = document.getElementById("edx-submit-different");
            var caution = document.getElementById("different-feedback");

            var glog = outputLog;
            var log = AG_log(glog);
            var feedback = log["feedback"];
            var title = log["comment"];

            // Checks if the grading button has been clicked
            if (title === "Please run the Snap Autograder before clicking the 'Submit' button.") {
                document.getElementById("table-data").style.display = "none";
                document.getElementById("reporter-table-data").style.display = "none";
            } else {
                document.getElementById("table-data").style.display = "table";
                document.getElementById("reporter-table-data").style.display = "table";
            }

            // Wipes the feedback clean, including if it has been populated before. 
            caution.innerHTML = "";
            edx_caution.innerHTML = "";
            document.getElementById("comment").innerHTML = "";
            var tableTitles = document.getElementsByClassName("titles");
            var tableResults = document.getElementById("table-data");
            var repTableResults = document.getElementById("reporter-table-data");
            while (tableResults.children.length > 1) {
                tableResults.removeChild(tableResults.children[1]);
            }
            while (repTableResults.children.length > 1) {
                repTableResults.removeChild(repTableResults.children[1]);
            }

            // Warnings for when student's feedback differ from what's on the scripting area/what's been submitted to edX
            document.getElementById("comment").innerHTML = title;
            if (!last_log) {
                edx_caution.innerHTML = "[WARNING: You have not submitted your results to edX yet.]"
            }
            else if (last_log !== prev_log) {
                edx_caution.innerHTML = "[WARNING: These results differ from your last edX submission.]"
            }

            var nonRepTest = 1;
            var repTest = 1;
            for (i=1; i<=feedback["testCount"]; i++) {
                var test = String(i);
                var newRow = document.createElement("tr");

                // If test is not a reporter test, only add columns for Test # and Feedback
                if (feedback[test]["testClass"] !== "r") {
                    if (document.getElementsByClassName("non-reporter").length === 0) {
                        addBasicHeadings();
                    }
                    addTableCell(String(nonRepTest), "tests", newRow);
                    nonRepTest += 1;
                }

                // If test is a reporter test, add all columns, including input, output, and expected. Makes the background of every other row light gray.
                if (feedback[test]["testClass"] === "r") {
                    if (document.getElementsByClassName("reporter").length === 0) {
                        addReporterHeadings();
                    }
                    addTableCell(String(repTest), "tests", newRow);
                    var keys = ["input", "output", "expOut"];
                    for (key=0; key<3; key++) {
                        if (repTest % 2 === 0) {
                            addTableCell(feedback[test][keys[key]], ["data", "evens"], newRow);
                        } else {
                            addTableCell(feedback[test][keys[key]], "data", newRow);
                        }
                    }
                    repTest += 1;
                }

                // If test is correct, make the feedback appropriately colored. 
                if (feedback[test]["correct"] === true) {
                    addTableCell(feedback[test]["feedback"], "correctans", newRow);
                    addTableCell("Regrade", ["data", "hidden"], newRow);
                } else {
                    addTableCell(feedback[test]["feedback"], "incorrectans", newRow);
                    addTableCell("Regrade", ["data", "regrade", test], newRow);
                }

                if (feedback[test]["testClass"] === "r") {
                    document.getElementById("reporter-table-data").appendChild(newRow);
                } else {
                    document.getElementById("table-data").appendChild(newRow);
                }  
            }
            console.log(outputLog);

            // makes recently created regrade buttons clickable 
            var regrade_buttons = document.getElementsByClassName("regrade");
            for(var i=0; i<regrade_buttons.length; i++) {
                regrade_buttons[i].onclick = function() {
                    var testId = this.classList[2];
                    regradeOnClick(outputLog, testId);
                }
            }
        }

        function addBasicHeadings() {
            basicCols = ["Test", "Feedback"];
            for (i=0; i<2; i++) {
                var header = document.createElement("th");
                var text = document.createTextNode(basicCols[i]);
                //var lastCol = document.getElementById("reporter-last-column");
                var titles = document.getElementById("table-titles");
                header.classList.add("titles", "non-reporter");
                header.appendChild(text);
                titles.appendChild(header);
            }
        }

        function addReporterHeadings() {
            var columns = ["Test", "Input", "Output", "Expected", "Feedback"];
            for (i=0; i<5; i++) {
                var header = document.createElement("th");
                var text = document.createTextNode(columns[i]);
                var repTitles = document.getElementById("reporter-table-titles");
                header.classList.add("titles", "reporter");
                header.appendChild(text);
                repTitles.appendChild(header);
            }
        }

        function addTableCell(text, elemClass, row) {
            var data = document.createElement("td");
            var text = document.createTextNode(text);
            data.appendChild(text);
            if (Array.isArray(elemClass)) {
                DOMTokenList.prototype.add.apply(data.classList, elemClass);
            } else {
                data.classList.add(elemClass);
            }
            row.appendChild(data);
        }

        function grayOutButtons(snapWorld, taskID) {
            var ide = snapWorld.children[0];
            var curr_xml = ide.serializer.serialize(ide.stage);
            //Retrieve previously graded Snap XML strings (if in localStorage).
            var c_prev_xml = localStorage.getItem(taskID + "_c_test_state");
            var prev_xml = localStorage.getItem(taskID + "_test_state");

            var last_xml = localStorage.getItem(taskID + "_last_submitted_state");

            var last_submit = document.getElementById("last-submit");
            if (last_xml === null || isSameSnapXML(last_xml, curr_xml)) {
                last_submit.style.color = "#373737";
                last_submit.style.pointerEvents = "none";
                last_submit.parentNode.id = "disabled-button";
            } else {
                last_submit.parentNode.id = "enabled-button";
                last_submit.style.color = "white";
                last_submit.style.pointerEvents = "auto";
            }

            var revert_button = document.getElementById("revert-button");
            if (c_prev_xml === null || isSameSnapXML(c_prev_xml, curr_xml)) {
                revert_button.style.color = "#373737";
                revert_button.style.pointerEvents = "none";
                revert_button.parentNode.id = "disabled-button";
            } else {
                revert_button.parentNode.id = "enabled-button";
                revert_button.style.color = "white";
                revert_button.style.pointerEvents = "auto";
            }

            var undo_button = document.getElementById("undo-button");
            if (prev_xml === null || isSameSnapXML(prev_xml, curr_xml)) {
                undo_button.style.color = "#373737";
                undo_button.style.pointerEvents = "none";
                undo_button.parentNode.id = "disabled-button";
            } else {
                undo_button.parentNode.id = "enabled-button";
                undo_button.style.color = "white";
                undo_button.style.pointerEvents = "auto";
            }
        }

        function regradeOnClick(outputLog, testId) {
                var test = outputLog[testId];
                test.graded = false;
                test.correct = false;
                outputLog.numAttempts += 1;
                //alert(typeof outputLog.startSnapTest);
                //outputLog.startSnapTest(2);
                //outputLog.startSnapTest(1);
                if (test.testClass === "r") {
                    outputLog.startSnapTest(parseInt(testId, 10));

                // for assertion tests, change feedback accordingly to what the assertion outputs
                } else if (test.testClass === "a") {
                    if (test.assertion()) {
                        test.feedback = test.pos_fb;
                        test.correct = true;
                    } else {
                        test.feedback = test.neg_fb;
                        test.correct = false;
                    }
                    test.graded = true;
                    populateFeedback(outputLog);
                    //outputLog.updateAssert(testId, )
                    //outputLog.startSnapTest(parseInt(testId, 10));
                }

                //What about other types of tests?

                //outputLog.startSnapTest(parseInt(testId, 10));
                outputLog.saveLog;
                console.log(outputLog);
                //this.classList[2]); 
        }

        var world;
        window.onload = function () {

            //check if attempt num for problem exists in local storage:

            //AUTOGRADER ADDITION - FEEDBACK FORMATTING
            // Checks if problem has been checked and modifies the autograded output if it has been checked

            if (parent.document.getElementsByClassName("message").length !== 0) {
                var hint = parent.document.getElementsByClassName("message")[0];
                hint.innerHTML = formatFeedback(hint);
                hint.style.display = "inline";
            }


            //INITIALIZE UP SNAP
            world = new WorldMorph(document.getElementById('world'));
            new IDE_Morph().openIn(world);


            var ide = world.children[0];
            //Reduce Stage Size on initialization
            ide.toggleStageSize(true);

            //AUTOGRADER ADDITION
            //Check if Pre-requisite task has completed
            var req_check = parent.document.getElementById("pre_req");
            if (preReqTaskID !== null) {
                var preReqLog = JSON.parse(localStorage.getItem(preReqID + "_test_log"));
                if ((preReqLog === null || !preReqLog.allCorrect) && req_check) {
                    req_check.innerHTML = "[WARNING: The previous task must be completed before continuing.]"
                }
            }

            //If page has already been loaded, restore previously tested XML
            //TODO: Separate this into its own function.
            var prev_xml = localStorage.getItem(id + "_test_state");
            if (prev_xml !== null) {
                ide.openProjectString(prev_xml);
            } else if (preReqTaskID !== null) {
                if (preReqLog !== null && preReqLog.allCorrect) {
                    ide.openProjectString(localStorage.getItem(preReqID));
                }
            }
            

            //AUTOGRADER ADDITION - 
            //Forced to use setTimeout() to let the world load before... Maybe not.
            
            //Create a gradingLog and initialize the AG status bar (AGSB).
            // var testLog = AGStart(world, id);

            //Initialize AGSB button.
            var grade_button = document.getElementById("autograding_button");
            grade_button.style.cursor = "pointer";
            //Call the test suite when this element is clicked.
            var update_listener = function() {
                AGUpdate(world, id);
            };
            var button_listener = function(event) {
                event.stopPropagation();
                console.log('PROPAGATION SHOULD STOP');
                outputLog = new gradingLog(world, id);
                outputLog.numAttempts += 1;
                runAGTest(world, id, outputLog);
                // var outputLog = AGStart(world, id);
            }
            grade_button.addEventListener('click', button_listener);
            var world_canvas = document.getElementById('world');
            world_canvas.addEventListener("mouseup", update_listener);

            // grade_button.onclick = function(event) {
            //     // event.stopPropagation();
            //     runAGTest(world, id);
            //     var outputLog = AGStart(world, id);
            //     //console.log(outputLog);
            //     //populateFeedback(outputLog);
            // }



            var reset_button = document.getElementById("reset-button");
            var revert_button = document.getElementById("revert-button");
            var undo_button = document.getElementById("undo-button");
            var last_submit = document.getElementById("last-submit");
            //var menu_button = document.getElementById("hamburger-menu");
            var menu_button = document.getElementsByClassName("onclick-menu")[0];
            //var help_menu = document.getElementById("circle");
            var help_overlay = document.getElementById('overlay');
            var feedback_button = document.getElementById("feedback-button");
            var results_overlay = document.getElementById("ag-output");
            var snapWorld = document.getElementById("world");
            var regrade_buttons = document.getElementsByClassName("regrade");

            reset_button.onclick = function() { resetState(world, id); };
            revert_button.onclick = function() { revertToBestState(world, id); };
            last_submit.onclick = function() { revertToLastSubmit(world, id); };
            undo_button.onclick = function() { revertToLastState(world, id); };
            menu_button.onclick = function() { toggleMenu(id); };


            /*regrade_buttons[0].onclick = function() {
                alert("hello");
            }*/

            /*document.getElementsByClassName("1")[0].onclick = function() {
                alert("hello");
            }*/

            $(".bubble").click(function(event){
                event.stopPropagation();  
            });

            feedback_button.onclick = function() {
                openResults();
            }

            help_overlay.onclick = function(e) {
                if (!(document.getElementById('help-popup').contains(e.target))) {
                    closePopup();
                }
            }

            /*results_overlay.onclick = function(e) {
                if (!(document.getElementById('ag-results').contains(e.target))) {
                    closeResults();
                }
            }*/

            snapWorld.onclick = function(e) {
                if (!(document.getElementById('dropdown-open').contains(e.target))) {
                    toggleMenu();
                }
            }


            /*help_menu.onclick = function() {
                openModal();
            }*/
            /* Check if the snap xml has changed "significantly".
             * Exclude script position and edit history.
             */


            /*document.addEventListener("click", function() {
                AGUpdate(world, id);
            });*/
            //TODO: Fix this timeout.
            setTimeout(function() {
                console.log(world);
                var outputLog = AGStart(world,id);
                //runAGTest(world, id);
                runAGTest(world, id);

                //for some reason, the for loop in populateFeedback doesn't increment correctly the first time it is run, so populateFeedback has to be called twice at the very beginning...
                populateFeedback(outputLog);
                //populateFeedback(outputLog);
                grayOutButtons(world, id);

                /*$(".regrade").click(function() {
                    var testId = this.classList[2];
                    var test = outputLog[testId];
                    test.graded = false;
                    test.correct = false;
                    outputLog.scoreLog;
                    console.log(outputLog);
                    var mylog = outputLog;
                    //this.classList[2]); 
                });*/

                
                /*for (i=0; i<regrade_buttons.length; i++) {
                    regrade_buttons[i].setAttribute('onclick', 'alert("hello")');
                }*/
                //populateFeedback(outputLog);
                //var outputLog = AGStart(world,id);
                //populateFeedback(outputLog);

                //for some reason, the for loop in populateFeedback doesn't increment correctly the first time it is run, so runAGTest has to be called twice at the very beginning...
                //runAGTest(world,id);
                //runAGTest(world,id);
                //AGUpdate(world, id);
            },600);

            //runAGTest(world,id);
            //AGUpdate(world, id);

            setInterval(loop, 1);
            
        };

        function loop() {
            world.doOneCycle();
        }

    </script>
    <script type="text/javascript" src="SnapPLE.js"></script>
    <script type="text/javascript" src="AG_EDX.js"></script>
</head>
<body style="margin: 0;">
    <canvas id="world" tabindex="1" style="position: absolute;" ></canvas>



<!-- Snap Autograding Button -->
<div id="autograding_bar">
    <div tabindex="0" class="onclick-menu" id='onclick-menu' style="display:inline-block">
        <span title="Menu">&#9776;</span>
        <div class='hover_darken'></div>
      <nav id="navigation" class="site-navigation" role="navigation">
          <ul id="dropdown-closed" class="bubble">
            <li class="menu-item-sub-menu" id="enabled-button"><a id="feedback-button">View Feedback</a></li>
            <li class="menu-divider-sub-menu" id='menu-divider'></li>
            <li class="menu-item-sub-menu" id="enabled-button"><a id="revert-button">Revert To Best Attempt</a></li>
            <li class="menu-item-sub-menu" id="enabled-button"><a id="last-submit">Revert To Last edX Submission</a></li>
            <li class="menu-item-sub-menu" id="enabled-button"><a id="undo-button">Revert To Last Attempt</a></li>
            <li class="menu-item-sub-menu" id="enabled-button"><a id="reset-button">Reset</a></li>
            <li class="menu-divider-sub-menu" id='menu-divider'></li>
            <li class="menu-item-sub-menu" id='enabled-button' onclick="openPopup();"><a id="help-button">Help</a></li>
          </ul>
    </nav>
    </div>
    <!-- <div id="autograding_flag" style="display:inline-block"></div> -->
    <!-- <div style="display:inline-block"> -->
    <div id="autograding_button" style="display:inline-block;">
        <span></span>
        <div class='hover_darken'></div>
    </div>
    <!-- </div> -->


<!-- Snap Autograding Menu -->

</div>

<!-- Autograding Menu Help Button -->
<!-- <div style="display:inline-block" class="AG-help-button" id="circle" onclick="openPopup();">?
</div> -->
<div class="overlay is-hidden" id="overlay">
    <div class="popup-content" id="help-popup">
        <span class="button-close" onclick="closePopup();">X</span>
            <p>
                Please remember to click the 'Submit' button below the Snap! window to obtain credit for this problem!
            </p>
            <div class="example-ag-buttons" id="ex-ungraded" style="display:inline-block;">
                &#9744;
            </div>
            <p style="display:inline-block;">
                The Snap! autograder has not been run yet.
            </p>
            </br>
            <div style="display:inline-block; color: orange;">&#x26A0;</div>
            <div class="example-ag-buttons" id="ex-semigraded" style="display:inline-block;">
                &#x2713;
            </div>
            <p style="display:inline-block;">
                The Snap! autograder has been run, but there are some errors in the code.
            </p>
            </br>
            <div class="example-ag-buttons" id="ex-graded" style="display:inline-block;">
                &#x2713;
            </div>
            <p style="display:inline-block;">
                The Snap! autograder has been run, and all the tests have passed!
            </p>
            </br>
    </div>
</div>

<div style="display:inline-block" class="view-results" id="circle" onclick="openResults();">Results
</div>
<div class="overlay is-hidden" id="ag-output">
    <div class="popup-content" id="ag-results">
        <span class="button-close" onclick="closeResults();" id="popup">X</span>
        <p id = "different-feedback"></p>
        <p id = "edx-submit-different"></p>
        <p id="comment"></p>
        <table class="results">
            <tbody id="table-data">
                <tr id="table-titles"> 
                    <!--<th class="titles"> Test </th> 
                    <th class="titles" id="last-column"> Feedback </th>-->
                </tr>
            </tbody>
        </table>
        </br>
        <table class="results">
            <tbody id="reporter-table-data">
                <tr id="reporter-table-titles"> 
                    <!--<th class="titles"> Test </th> 
                    <th class="titles" id="last-column"> Feedback </th>-->
                </tr>
            </tbody>
        </table>
    </div>
</div>


    </div>
    <script type="text/javascript" src="AG_status_bar.js" />
    <script type="text/javascript" src="SnapPLE.js"></script>
</body>
</html>